import {Component, OnInit, ElementRef, Input, OnChanges, Output, EventEmitter} from '@angular/core';
import {AngularFire, FirebaseListObservable} from 'angularfire2';

@Component({
  selector: 'map-app',
  templateUrl: 'app/components/map/map.component.html',
  styleUrls: ['app/components/map/map.component.css']
})
export class MapComponent implements OnInit, OnChanges {
  /**
   * Flag that equals true when the flash should be created
   * on the current user location throu geo localization.
   */
  @Input('is-on-place') isOnPlace: boolean;

  /**
   * Emits the signal whenever a flash is created.
   * @externally: boolean
   * Tells if it was generated by an external actions
   * or internally with the own maps controls.
   * It will also send the marker object along the event.
   */
  @Output('flash-created') flashCreated = new EventEmitter();

  /**
   * Emits the signal whenever a flash is clicked.
   * @marker: the marker selected.
   */
  @Output('marker-selected') markerSelected = new EventEmitter();

  protected map: google.maps.Map;

  /**
   * Center map. Required.
   */
  center: google.maps.LatLng;

  /**
   * The initial map zoom level. Required.
   */
  zoom: number;

  /**
   * The initial map mapTypeId. Defaults to ROADMAP.
   */
  mapTypeId: google.maps.MapTypeId;

  /**
   * Enables/disables street view.
   */
  streetViewControl: boolean;

  /**
   * Enables/disables map markers.
   */
  mapMarker: boolean;

  /**
   * The marker representing the position of
   * the flash that the user is about to upload.
   */
  savedFlash: google.maps.Marker;
  
  flashes: FirebaseListObservable<any>;
  
  private loadFlashes() {
    this.flashes.forEach((flashArray) => {
      flashArray.forEach((flashObject) => {
        let pos = new google.maps.LatLng(flashObject.lat, flashObject.lng);
        this.createFlash(pos, flashObject.title, false, false, false, false, true, flashObject.id, flashObject.description, flashObject.date);
        this.savedFlash = undefined;
      });
    });
  }
  
  /**
   * Create an info window with the specified text
   * that later can be opened clicking on its marker.
   */
  private createInfoWindow(text: string) {
    return new google.maps.InfoWindow({
      content: text
    });
  }

  /**
   * Create a marker to place inside the map.
   * It sets random number as its default ID.
   */
  private createMarker(position: google.maps.LatLng, exist: boolean, id: number) {
    let marker = new google.maps.Marker({
      map: this.map,
      draggable: exist,
      position: position,
      visible: true
    });

    marker.setValues({
      id: id || Math.round(Math.random() * (999 - 100) + 100) // 100<->999
    });

    return marker;
  }

  /**
   * Resizes the map, updating its center.
   */
  private resize() {
    // Saves the center.
    let latLng: google.maps.LatLng = this.map.getCenter();

    // Triggers resize event.
    google.maps.event.trigger(this.map, 'resize');

    // Restores the center.
    this.map.setCenter(latLng);
  }

  private openInfoWindow(infoWindow: google.maps.InfoWindow, marker: google.maps.Marker) {
    infoWindow.open(marker.get('map'), marker);
    this.markerSelected.emit({
      marker: marker
    });
  }

  /**
   * Create a marker, store it, positionate
   * the map and open an info window.
   *
   * @position: google maps LatLng object.
   * @text: optionally set a text for the info window object.
   * @unique: optionally create and set as the only flash on the map.
   * @center: optionally center the map on the given position.
   * @infoWindowOpened: optionally open the info window.
   * @externally: set to true when the flash is created by an external action.
   * @exist:
   * @id:
   * @description:
   * @date:
   * This is useful to notify the parent component that the intended creation was sucessful.
   */
  private createFlash(position: google.maps.LatLng, text: string, unique: boolean, center: boolean, infoWindowOpened: boolean, externally: boolean, exist: boolean, id: number, description: string, date: string) {
    if (center) {
      this.map.setCenter(position);
    }

    /**
     * If the new flash will replace the previous one
     * then the later has to be removed from the map.
     */
    if (unique && this.savedFlash) {
      this.savedFlash.setMap(null);
    }
    
    let marker = this.savedFlash = this.createMarker(position, !exist, id);
    text = text || 'Id: '+ marker.get('id');
    let infoWindow = this.createInfoWindow(text);
    
    if (infoWindowOpened) {
      this.openInfoWindow(infoWindow, marker);
    } else {
      marker.addListener('click', function() {
        this.openInfoWindow(infoWindow, marker);
        infoWindow.open(marker.get('map'), marker);
      }.bind(this));
    }
    
    marker.setValues({
      title: text,
      description: description,
      date: date
    })
    
    this.flashCreated.emit({
      externally: !!externally,
      marker: marker
    });
  }

  constructor(public elementRef: ElementRef, af: AngularFire) {
    //Get all flashes from angularfire2
    this.flashes = af.database.list('/flashes');   
    
    // Sets initial center map.
    this.center = new google.maps.LatLng(-38.416097, -63.616672);

    this.mapTypeId = google.maps.MapTypeId.ROADMAP;

    // Sets the initial zoom.
    this.zoom = 4;

    // Disable street view
    this.streetViewControl = false;

    // Enable map marker
    this.mapMarker = true;
  }

  /**
   * Watch an external boolean property to see
   * when the user wants to enable geo location
   * and mark it as the place to create the flash.
   */
  ngOnChanges() {
    if (this.isOnPlace) {
      if (!navigator.geolocation) {
        console.error('Geolocation is not supported by this browser.');
        return;
      }

      navigator.geolocation.getCurrentPosition(function(position) {
        let pos = new google.maps.LatLng(position.coords.latitude, position.coords.longitude);
        this.createFlash(pos, null, true, true, false, true, false, null);
      }.bind(this), function() {
        console.error('Error on get current position');
      });
    }
  }

  ngOnInit() {
    let mapOptions = {
      center: this.center,
      mapMarker: this.mapMarker,
      mapTypeId: this.mapTypeId,
      streetViewControl: this.streetViewControl,
      zoom: <number>this.zoom
    };

    // Instances the map.
    let el: HTMLElement = this.elementRef.nativeElement.querySelector('#map');
    this.map = new google.maps.Map(el, mapOptions);
    
    this.loadFlashes();

    window.addEventListener('resize', () => { this.resize(); });

    this.map.addListener('click', function(event) {
      this.createFlash(event.latLng, null, true);
      // TODO: open the form to load the data
    }.bind(this));

    /**
     * Create the search box and link it to the UI element.
     */
    let input: HTMLInputElement = this.elementRef.nativeElement.querySelector('#pac-input');
    let searchBox = new google.maps.places.SearchBox(input);
    this.map.controls[ google.maps.ControlPosition.TOP_LEFT ].push(input);

    /**
     * This callback is executed when the user select a place in the search box.
     * It will show specifically that place in the map and create the flash there.
     * An info window will be shown with a useful message to the user about how to use the marker.
     */
    searchBox.addListener('bounds_changed', function() {
      let position = searchBox.getBounds().getCenter();
      let message = 'You can drag me! Make sure of the place using Satellite view!';
      this.createFlash(position, message, true, false, true);
      this.map.fitBounds(searchBox.getBounds());
    }.bind(this));

    // Listen for the event fired when the user selects a prediction and retrieve
    // more details for that place.
    searchBox.addListener('places_changed', function() {
      let places = searchBox.getPlaces();

      if (!places.length) {
        return;
      }

      // For each place, get the icon, name and location.
      let bounds = new google.maps.LatLngBounds();

      places.forEach(function(place) {
        let icon = {
          url: place.icon,
          size: new google.maps.Size(71, 71),
          origin: new google.maps.Point(0, 0),
          anchor: new google.maps.Point(17, 34),
          scaledSize: new google.maps.Size(25, 25)
        };

        if (place.geometry.viewport) {
          // Only geocodes have viewport.
          bounds.union(place.geometry.viewport);
        } else {
          bounds.extend(place.geometry.location);
        }
      });

      this.setBounds(bounds);
    });
  }
}
